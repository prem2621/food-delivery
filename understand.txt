ğŸ§  1ï¸âƒ£ First: Token na enna?

â€œTokenâ€ na oru digital identity proof or access pass madhiri.

Example:

You login to a website â†’ server gives you a token â†’ you show that token next time instead of username/password â†’ server
 trusts you.
 So every time username & password send panna vendam â€” token proves â€œIâ€™m already authenticatedâ€.



ğŸ” 2ï¸âƒ£ JWT na full form enna?

JWT = JSON Web Token 
ğŸ§¾ JSON â†’ readable format (like { "id": "123", "name": "Prem" })
ğŸ§  Web Token â†’ used in web systems for secure data exchange 
So JWT = A compact, secure way to send user info as a token.



ğŸ¯ 3ï¸âƒ£ Purpose of JWT

JWT is mainly used for: 
âœ… Authentication â€“ verify user identity after login 
ğŸ”„ Authorization â€“ check whether user can access a route (like admin dashboard) 
âš™ï¸ Data transfer security â€“ exchange info between client & server safely





ğŸ§© 4ï¸âƒ£ JWT token structure (3 parts)

JWT token looks like this ğŸ‘‡
xxxxx.yyyyy.zzzzz
| Part | Name          | Purpose                                              |
| ---- | ------------- | ---------------------------------------------------- |
| 1ï¸âƒ£  | **Header**      | Contains token type & algorithm (like HS256)         |
| 2ï¸âƒ£  | **Payload**     | Contains actual data (user info like id, role, etc.) |
| 3ï¸âƒ£  | **Signature**   | Verification signature (so no one can modify token)  |

Header: { "alg": "HS256", "typ": "JWT" }
Payload: { "id": "123", "name": "Prem", "role": "user" }
Signature: HMACSHA256(header + payload + secret)





ğŸ§  5ï¸âƒ£ How JWT works (step-by-step)

Letâ€™s say user Prem login panra ğŸ‘‡
Prem â†’ sends username + password to server
Server â†’ verifies credentials
Server â†’ creates JWT with user info + secret key
Server â†’ sends that JWT back to frontend
Frontend â†’ stores token (usually in localStorage or cookies)
Next request la â†’ frontend sends JWT in header
Server â†’ verifies JWT signature using secret key 
If valid â†’ gives access, else â†’ 401 Unauthorized



CartData Explanation

The cartData field in your Mongoose schema is designed to store a user's shopping cart information within the same user document. 
Since you're creating this for a signup process, it ensures that every new user record has an associated cart structure, 
even if it's initially empty. ğŸ›’


Field Details
Here's a breakdown of the specific settings for the cartData field:

type: Object: This tells Mongoose and MongoDB that the data stored in cartData will be a JSON object. A shopping cart
 typically needs to store key-value pairs, where the "key" might be the ID of a product and the "value" might be the
  quantity of that product the user wants to buy. An Object type is perfect for this flexible, non-fixed structure.
Example structure inside cartData: {"product_id_1": 2, "product_id_2": 1} (meaning 2 of product 1 and 1 of product 2).
default: {}: This sets the default value for the field. When a new user signs up and you create a new user document,
 Mongoose will automatically set the cartData to an empty object ({}) if you don't explicitly provide a value. 
 This is useful because a new user's cart is empty when they first create an account.
Why we include it in the schema: You include cartData here so that you can manage the user's cart directly from their
 user document. This is a common pattern in e-commerce applications. When a user adds an item to their cart, you'll 
 simply update this cartData object in their existing user document. This makes it easier to fetch both the user details
  and their cart data in a single database query.

What is minimize:false?

The {minimize:false} option at the end of your schema definition is a Mongoose schema option.
Default Behavior (minimize:true): By default, Mongoose sets minimize to true. This means if you save an object to the 
database that only contains empty objects (like your {}) or objects with no data, Mongoose will remove them from the 
document before saving it to MongoDB.
With minimize:false: Setting it to false instructs Mongoose to preserve all empty objects. In the context of your
 cartData: { type: Object, default: {} }, this is important because you want the empty cartData object to always exist
  in the document, even when the user hasn't added anything yet. This makes it easier for your application code to read 
  and update the cart later, as it can always rely on the cartData field being present.








In the provided code, hashing the password is a critical security step. It ensures that the user's actual, plain-text
 password is never stored in your database. ğŸ”’

Password Hashing Explained
What is Hashing?
Hashing is the process of transforming any input (like a password) into a fixed-size, seemingly random string of
 characters
 (the hash) using a mathematical algorithm.
One-Way: A key feature is that hashing is one-way. You can easily create a hash from a password, but you cannot reverse
 the process to get the original password back from the hash.

Why Hashing? (The Security Reason)
If your database is ever compromised (hacked), the attackers will only get the hashed passwords, not the actual passwords.
 Since hashing is one-way, the attacker cannot log in as the user. If passwords were stored in plain text, a breach
  would expose every user's password immediately.

The Algorithm:
You are using the bcrypt algorithm, which is a popular and very secure hashing function specifically designed for passwords.

Deeper Look at bcrypt and salt
The lines you asked about use the bcrypt library to secure the password:

const salt = await bcrypt.genSalt(10);
const hashedPassword = await bcrypt.hash(password, salt);
1. const salt = await bcrypt.genSalt(10);
bcrypt.genSalt(): This is the function that generates a unique salt.

What is a Salt?
A salt is a random string of characters that is generated individually for every single password being hashed.
The Number 10: This is the cost factor or "work factor." It determines how computationally intensive the hashing process
 should be. A higher number (e.g., 12 or 14) means the hashing takes longer (which is good for security) but also uses
  more CPU resources. 10 is a widely accepted, secure value.

Why use Salt? (To prevent Rainbow Table Attacks)
If two users have the same simple password (e.g., "123456"), hashing them without a salt would result in the exact same 
hash in the database.
By adding a unique salt to the password before hashing, even if two users have the same password, their final 
hashedPassword will be completely different. This defeats a common hacking technique called a Rainbow Table Attack.
The Variable Name salt: It's named salt because that is the security term for this random data.

2. const hashedPassword = await bcrypt.hash(password, salt);
bcrypt.hash(): This is the main function that performs the hashing.
The Process: It takes the plain-text password, mixes it with the unique salt, and then runs this combined string
 through the intense bcrypt algorithm to produce the final hash.
What's Stored?: The final hashedPassword that gets stored in your database is actually a combination of the algorithm
 version, the cost factor (10), the unique salt, and the final hash itself. The bcrypt library intelligently stores
  all the necessary information together so it knows exactly how to verify the password later.



Verification (How a User Logs In)
When a user tries to log in:

They provide a plain-text password.
Your code fetches the stored hashedPassword (which contains the salt) from the database.
You use a function like bcrypt.compare(plainTextPassword, hashedPasswordFromDB).
bcrypt automatically extracts the salt and cost factor from the stored hash, hashes the new plainTextPassword using that
 same salt, and then checks if the newly generated hash matches the stored hash.
If they match, the login is successful! The original password is never exposed or revealed.

 